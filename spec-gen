#!/usr/bin/env python
"""usage: %prog [options] input output

Post-process a document, adding cross-references, table of contents, etc.
"""

import cProfile
from optparse import OptionParser
import sys
import html5lib
from html5lib import treebuilders, treewalkers, serializer
import lxml.html
from lxml import etree

from specGen import generator

def main():
	# Create the options parser
	optParser = getOptParser()
	opts, args = optParser.parse_args()
	
	# Check we have enough arguments
	if len(args) >= 2:
		# Get input/output
		input = file(args[0], "r")
		output = file(args[1], "w")
		
		# Parse as XML:
		if opts.xml:
			tree = etree.parse(input)
		# Parse as HTML using lmxl.html
		elif opts.lxml_html:
			tree = lxml.html.parse(input)
		# Parse as HTML using html5lib
		else:
			parser = html5lib.HTMLParser(tree=treebuilders.getTreeBuilder("lxml", etree))
			tree = parser.parse(input)
		
		# Create the generator
		gen = generator.generator()
		
		# Turn the options into a dict
		kwargs = vars(opts)
		
		# Run the generator, and profile, or not, as the case may be
		if kwargs["profile"]:
			cProfile.runctx("gen.process(tree, **kwargs)", {}, {"gen": gen, "tree": tree, "kwargs": kwargs})
		else:
			gen.process(tree, **kwargs)
		
		# Serialize to XML
		if opts.xml:
			rendered = etree.tostring(tree, encoding="utf-8")
		# Serialize to HTML using lxml.html
		elif opts.lxml_html:
			rendered = lxml.html.tostring(tree, encoding="utf-8")
		# Serialize to HTML using html5lib
		else:
			walker = treewalkers.getTreeWalker("lxml")
			s = serializer.htmlserializer.HTMLSerializer(**kwargs)
			rendered = s.render(walker(tree), encoding="utf-8")
		
		# Write to the output
		output.write(rendered)
	else:
		sys.stderr.write("spec-gen expects two arguments. Use -h for help\n")
		sys.exit(1)

def getOptParser():
	parser = OptionParser(usage = __doc__)
	
	parser.add_option("", "--xml", action="store_true",
		default=False, dest="xml", help="Use an XML parser/serializer.")
	
	parser.add_option("", "--lxml.html", action="store_true",
		default=False, dest="lxml_html", help="Use lxml's HTML parser/serializer.")
	
	parser.add_option("", "--min-depth", action="store", type="int",
		default=2, dest="min_depth", help="Highest ranking header to number/insert into TOC.")
	
	parser.add_option("", "--max-depth", action="store", type="int",
		default=6, dest="max_depth", help="Lowest ranking header to number/insert into TOC.")
	
	parser.add_option("", "--allow-duplicate-terms", action="store_true",
		default=False, dest="allow_duplicate_terms", help="Allow multiple definitions of terms when cross-referencing (the last instance of the term is used when referencing it).")
	
	parser.add_option("", "--w3c-compat", action="store_true",
		default=False, dest="w3c_compat", help="Behave in a (mostly) compatible way to the W3C CSS WG's Postprocessor.")
	
	parser.add_option("", "--w3c-compat-xref-elements", action="store_true",
		default=False, dest="w3c_compat_xref_elements", help="Uses the same list of elements to look for cross-references in as the W3C CSS WG's Postprocessor, even when the elements shouldn't semantically be used for cross-reference terms.")
	
	parser.add_option("", "--w3c-compat-xref-a-placement", action="store_true",
		default=False, dest="w3c_compat_xref_a_placement", help="When cross-referencing elements apart from span, put the a element inside the element instead of outside the element.")
	
	parser.add_option("", "--w3c-compat-xref-normalization", action="store_true",
		default=False, dest="w3c_compat_xref_normalization", help="Only use ASCII letters, numbers, and spaces in comparison of cross-reference terms.")
	
	parser.add_option("", "--w3c-compat-class-toc", action="store_true",
		default=False, dest="w3c_compat_class_toc", help="Add @class='toc' on every ol element in the table of contents (instead of only the root ol element).")
	
	parser.add_option("", "--profile", action="store_true",
		default=False, dest="profile", help="Profile the execution of %prog.")
	
	parser.add_option("", "--inject-meta-charset", action="store_true",
		default=False, dest="inject_meta_charset", help="inject <meta charset>")
	
	parser.add_option("", "--strip-whitespace", action="store_true",
		default=False, dest="strip_whitespace", help="strip whitespace")

	parser.add_option("", "--omit-optional-tags", action="store_true",
		default=False, dest="omit_optional_tags", help="omit optional tags")

	parser.add_option("", "--quote-attr-values", action="store_true",
		default=False, dest="quote_attr_values", help="quote attribute values")

	parser.add_option("", "--use-best-quote-char", action="store_true",
		default=False, dest="use_best_quote_char",	help="use best quote character")

	parser.add_option("", "--no-minimize-boolean-attributes",
		action="store_false", default=True,
		dest="minimize_boolean_attributes", help="minimize boolean attributes")

	parser.add_option("", "--use-trailing-solidus", action="store_true",
		default=False, dest="use_trailing_solidus", help="use trailing solidus")

	parser.add_option("", "--space-before-trailing-solidus",
		action="store_true", default=False,
		dest="space_before_trailing_solidus", help="add space before trailing solidus")

	parser.add_option("", "--escape-lt-in-attrs", action="store_true",
		default=False, dest="escape_lt_in_attrs", help="escape less than signs in attribute values")

	parser.add_option("", "--escape-rcdata", action="store_true",
		default=False, dest="escape_rcdata", help="escape rcdata element values")

	parser.add_option("", "--sanitize", action="store_true", default=False,
		dest="sanitize", help="sanitize")

	return parser

if __name__ == "__main__":
	main()